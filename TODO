- validate all incoming data fields in the message, clear all values
  which are not suppoed to be set from a peer

- check that the appendend data block sizes, and that individual records
  have the proper size and that the last listed record validly ends at
  the overall message size provided in the header

- always align to 8 byte boundaries, keep size correct, but start next
  record at proper offset

- use subsys_virtual_register() to avoid devices showing up directly
  in the root of /sys/devices/
    https://git.kernel.org/cgit/linux/kernel/git/tj/wq.git/commit/?h=for-3.10-subsys_virtual_register

- switch to hashmap for connection id <--> kdbus_conn


API related:


CASE:

What if a client (A) acquires a name with KDBUS_CMD_NAME_STARTER set in flags.

Another client (B) sends a message with flags == 0, which will start the
service of connection A.

Yet client (C) comes along, sending a message with KDBUS_MSG_FLAGS_NO_AUTO_START
NOT send in flags. That message will be rejected, even though client A already
started the service.

How do we handle this?

