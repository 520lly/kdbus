Recent:
  - allow only anonymous or protected/busy memory to pass with map
  - enforce page align of mmap memory
  - one fd only per data record?
  - coalesce fd data records into one single record at _recv()
  - allow to coalesce memory records, but do not mix MMAP and PAYLOAD
  - suppress _DST_NAME, _BLOOM records at _recv()

Bugs:
  - check for duplicate bus names before registering:
      kobject_add_internal failed for kdbus!0-xxxx!bus with EEXIST

Message Buffering:
  - kmalloc is limited to < 128k
  - handle fds
  - pass along mappings of userspace data, instead of copying them

Security:
  - let HELLO specify if fds or mmaps() are accepted to
    be received; refuse the message otherwise
  - limit file descriptor passing to unicast, never try to broadcast them

Mesage Validation:
  - enforce NULL termination on all strings. Do not rely on the size
    headers
  - validate all incoming data fields in the message, clear all values
    which are not supposed to be set from a peer
  - always align data records to 8 byte boundaries, keep size correct,
    but start next record at proper offset

External API:
  - size in data records includes the data header size? it also does
    not include the padding
  - check that enum values of 0 make sense, otherwise insert "*_NONE,"
  - add some "uint64_t reserved" in the basic structures?

Kernel Core:
  - use subsys_virtual_register() to avoid devices showing up directly
    in the root of /sys/devices/
      https://git.kernel.org/cgit/linux/kernel/git/tj/wq.git/commit/?h=for-3.10-subsys_virtual_register


API Question:
  What if a client (A) acquires a name with KDBUS_CMD_NAME_STARTER set in flags.

  Another client (B) sends a message with flags == 0, which will start the
  service of connection A.

  Yet client (C) comes along, sending a message with KDBUS_MSG_FLAGS_NO_AUTO_START
  NOT send in flags. That message will be rejected, even though client A already
  started the service.

