Message Buffering:
  - kmalloc is limited to < 128k
  - handle fds
  - pass along mappings of userspace data, instead of copying them

Security:
  - let HELLO specify if fds or mmaps() are accepted to
    be received; refuse the message otherwise
  - limit file descriptor passing to unicast, never try to broadcast them
  - allow only anonymous mappings to be transferred; or find a way to
    ensure that file-based mappings can never change the content
    when the file content changes (reflink)

Mesage Validation:
  - enforce NULL termination on all strings. Do not rely on the size
    headers
  - validate all incoming data fields in the message, clear all values
    which are not supposed to be set from a peer
  - always align data records to 8 byte boundaries, keep size correct,
    but start next record at proper offset

External API:
  - size in data records includes the data header size? it also does
    not include the padding
  - check that enum values of 0 make sense, otherwise insert "*_NONE,"
  - add some "uint64_t reserved" in the basic structures?
  - make sure all (custom) clients must handle PAYLOAD_REF; they can
    never rely on the sender format, or autmatic inlining --> when we
    add mmap() at recv(), things must keep working

Kernel Core:
  - use subsys_virtual_register() to avoid devices showing up directly
    in the root of /sys/devices/
      https://git.kernel.org/cgit/linux/kernel/git/tj/wq.git/commit/?h=for-3.10-subsys_virtual_register


API Question:
  What if a client (A) acquires a name with KDBUS_CMD_NAME_STARTER set in flags.

  Another client (B) sends a message with flags == 0, which will start the
  service of connection A.

  Yet client (C) comes along, sending a message with KDBUS_MSG_FLAGS_NO_AUTO_START
  NOT send in flags. That message will be rejected, even though client A already
  started the service.

