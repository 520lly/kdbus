Message Buffering:
  - kmalloc is limited to < 128k
  - pass along mmap() of process data, instead of copying them

Security:
  - let HELLO specify if fds or mmaps() are accepted to
    be received; refuse the message otherwise

Mesage Validation:
  - enforce NULL termination on all strings. Do not rely on the size
    headers only
  - validate all incoming data fields in the message, clear all values
    which are not supposed to be set from a peer
  - always align data records to 8 byte boundaries, keep size correct,
    but start next record at proper offset
  - allow only anonymous or protected/busy memory to pass with mmap()

Message augmentation:
  - when do we append KDBUS_MSG_SRC_{COMM,EXE,CMDLINE,CGROUP}?
  - define a payload type for kernel-gererated messages

External API:
  - size in data records includes the data header size? it also does
    not include the padding
  - check that enum values of 0 make sense, otherwise insert "*_NONE,"
  - enforce strict page alignement of mmap()ed memory in the API
  - allow to coalesce memory records, but never mix MMAP and PAYLOAD
  - support optional addition of cgroup, comm, exe, ... of the sender
    process
  - always put \0 in the padding bytes?
  - enforce 8-byte align of send/recv buffer
  - have some sort of kdbus kernel protocol negotiation. how do we deal
    with changes later on?
  - as we have u64 for sizes in the ioctl()-passed structs, we need a
    way to deal with 32-bit architectures. Passing an u64 to get_user()
    results in an unresolved reference to __get_user_bad.

Internal API:
  - use size_t instead of u64 for internal variables where appropriate?

Name database:
  - look up name information, how are we supposed to get the data back to
    userspace?

Kernel Core:
  - use subsys_virtual_register() to avoid devices showing up directly
    in the root of /sys/devices/
      https://git.kernel.org/cgit/linux/kernel/git/tj/wq.git/commit/?h=for-3.10-subsys_virtual_register


API Question:
  What if a client (A) acquires a name with KDBUS_CMD_NAME_STARTER set in flags.

  Another client (B) sends a message with flags == 0, which will start the
  service of connection A.

  Yet client (C) comes along, sending a message with KDBUS_MSG_FLAGS_NO_AUTO_START
  NOT send in flags. That message will be rejected, even though client A already
  started the service.

